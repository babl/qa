#input {
#  # ./supervisor2 -l=:4445 -kb=queue.babl.sh:9092 2>&1 | nc 127.0.0.1 12300
#  tcp {
#    port => "12300"
#    add_field => {
#      type => "os"
#      level => "info"
#      service => "supervisor2"
#      host => "babl-queue1"
#      "[@metadata][__index_name]" => "logstash"
#    }
#  }
#
#  # ./babl-server -kb=queue.babl.sh:9092 -m larskluge/string-upcase 2>&1 | nc 127.0.0.1 12500
#  tcp {
#    port => "12500"
#    add_field => {
#      type => "module"
#      level => "info"
#      module => "larskluge/string-upcase"
#      host => "babl-slave4"
#      module_version => "v45"
#      image_name => "registry.babl.sh/larskluge/string-upcase:v45"
#      SERVICE_TAGS => "babl"
#      "[@metadata][__index_name]" => "logstash"
#    }
#  }
#}
#filter {
#  mutate {
#    add_field => {
#      "[@metadata][__logs_babl]" => "logs.babl"
#    }
#  }
#  if [message][rid] {
#    mutate {
#      add_field => {
#        "[@metadata][__logs_rid]" => "logs.qa"
#      }
#    }
#  }
#}
#output {
#  # For debugging
#  stdout { codec => rubydebug { metadata => true } }
#
#  if [@metadata][__logs_babl] {
#    kafka {
#      bootstrap_servers => "queue.babl.sh:9092"
#      topic_id => "%{[@metadata][__logs_babl]}"
#    }
#  }
#
#  if [@metadata][__logs_rid] {
#    kafka {
#      bootstrap_servers => "queue.babl.sh:9092"
#      topic_id => "%{[@metadata][__logs_rid]}"
#    }
#  }
#}


input {
  udp {
    type => "os"
    port => 4987
    add_field => {
      "[@metadata][__type]" => "os"
      "[@metadata][__index_name]" => "logstash"
      "[@metadata][__input]" => "tcp"
    }
  }
  gelf {
    type => "module"
    port => 4988
    add_field => {
      "[@metadata][__type]" => "module"
      "[@metadata][__index_name]" => "logstash"
      "[@metadata][__input]" => "gelf"
    }
  }
  gelf {
    type => "web"
    port => 4990
    add_field => {
      "[@metadata][__type]" => "web"
      "[@metadata][__index_name]" => "logstash"
      "[@metadata][__input]" => "gelf"
    }
  }
  # ./supervisor2 -l=:4445 -kb=queue.babl.sh:9092 2>&1 | nc 127.0.0.1 12300
  tcp {
    port => "12300"
    add_field => {
      "type" => "os"
      "level" => "info"
      "service" => "supervisor2"
      "host" => "babl-queue1"
      "[@metadata][__type]" => "os"
      "[@metadata][__index_name]" => "logstash"
      "[@metadata][__input]" => "tcp"
    }
  }
  # ./babl-server -kb=queue.babl.sh:9092 -m larskluge/string-upcase 2>&1 | nc 127.0.0.1 12500
  tcp {
    "port" => "12500"
    add_field => {
      "type" => "module"
      "level" => "info"
      "module" => "larskluge/string-upcase"
      "host" => "babl-slave4"
      "module_version" => "v45"
      "image_name" => "registry.babl.sh/larskluge/string-upcase:v45"
      "SERVICE_TAGS" => "babl"
      "[@metadata][__type]" => "module"
      "[@metadata][__index_name]" => "logstash"
      "[@metadata][__input]" => "gelf"
    }
  }
}
filter {
  #----------------------
  # module + web (pre-processing)
  #----------------------
  if [@metadata][__input] == "gelf" {
    mutate {
      remove_field => ["version", "level", "facility", "command", "container_name", "tag", "source_host"]
      rename => {
        "[short_message]" => "message"
        "[BABL_MODULE]" => "module"
        "[BABL_MODULE_VERSION]" => "module_version"
      }
      add_field => {
        "[@metadata][__log_channel]" => "babl:log:module:%{module}"
      }
    }
  }
  #----------------------
  # OS
  #----------------------
  if [type] == "os" {
    # original message will be stored into jsondata
    mutate {
      add_field => {
        "jsondata" => "%{message}"
      }
    }
    json {
      source => "message"
      target => "data"
    }
    # INFO: do not rename: "[data][msg]" => "message (see the last block)"
    mutate {
      rename => {
        "[data][_HOSTNAME]" => "external_host"
        "[data][MESSAGE]" => "message"
        "[data][_SYSTEMD_UNIT]" => "service"
        "[data][rid]" => "rid"
        "[data][key]" => "key"
        "[data][msg]" => "message"
        "[data][duration_ms]" => "duration_ms"
        "[data][level]" => "level"
        "[data][topic]" => "topic"
        "[data][partition]" => "partition"
        "[data][offset]" => "offset"
        "[data][time]" => "timestamp"
      }
      convert => {
        "duration_ms" => "float"
      }
    }
    mutate {
      gsub => [
        "service", "\.service$", ""
      ]
		}
    if ! [service] and [data][SYSLOG_IDENTIFIER] {
      mutate {
        rename => {
          "[data][SYSLOG_IDENTIFIER]" => "service"
        }
      }
		}
    mutate {
      add_field => {
				"[@metadata][__log_channel]" => "babl:log:admin:%{host}:%{service}"
      }
      remove_field => ["data", "port"]
    }
    # server-status error notification
    if [service] == "server-status" and ("start server" in [message] or "stop server" in [message]) {
      mutate {
        add_field => {
          "[@metadata][__notify]" => "ERROR %{service} on %{host}: %{message}"
        }
      }
    }
    # test
    #if [service] == "supervisor2" and ("New Message Received" in [message] or "Module responded" in [message]) {
    #  mutate {
    #    add_field => {
    #      "[@metadata][__debug]" => true
    #    }
    #  }
    #}
    # pipes supervisor2 messages with rid field into kafka.logs.qa
    if [service] == "supervisor2" and [jsondata] =~ "\"rid\":" {
      mutate {
        add_field => {
          "hostname" => "%{host[-1]}"
          "[@metadata][__logs_rid]" => "logs.qa"
          "[@metadata][__debug]" => true
        }
      }
    }
    # INFO: mandatory to be the last block, will rename: "[data][message]" => "message"
    mutate {
      rename => {
        "[data][msg]" => "message"
      }
    }
    # remove data field
    mutate {
      remove_field => ["data"]
    }
  }
  #----------------------
  # MODULE + WEB
  #----------------------
  if [type] == "module" {

    if [message] =~ "^\{" or [message] =~ "call" {
      # pipes babl-server app call response message into influxdb
      if [message] =~ "call" {
        mutate {
          add_field => {
            "[@metadata][__logs_call]" => "logs.call"
          }
        }
      }

      # original message will be stored into jsondata
      mutate {
        add_field => {
          "jsondata" => "%{message}"
        }
      }

      # parse message
      json {
        source => "message"
        target => "data"
      }
      # INFO: do not rename: "[data][msg]" => "message (see the last block)"
      mutate {
        rename => {
          "[data][rid]" => "rid"
          "[data][key]" => "key"
          "[data][duration_ms]" => "duration_ms"
          "[data][error]" => "error"
          "[data][exitcode]" => "exitcode"
          "[data][level]" => "level"
          "[data][status]" => "status"
          "[data][stderr]" => "stderr"
          "[data][stdin]" => "stdin"
          "[data][stdout]" => "stdout"
          "[data][topics][0]" => "topic"
          "[data][topic]" => "topic"
          "[data][partition]" => "partition"
          "[data][offset]" => "offset"
          "[data][time]" => "timestamp"
        }
        convert => {
          "stdin" => "integer"
          "stdout" => "integer"
          "stderr" => "integer"
          "exitcode" => "integer"
          "status" => "integer"
          "duration_ms" => "float"
        }
      }

      # check if message contains '"env":' + '"error":'
      # NOTE: specific failure on babl/events child module call (bablbot,mail,slack-push)
      if [message] =~ "\"env\":.*\"error\":" {
        # parse message
        json {
          source => "message"
          target => "dataenv"
        }
        mutate {
          rename => {
            "[dataenv][error]" => "error"
            "[dataenv][exitcode]" => "exitcode"
            "[dataenv][msg]" => "message"
            "[dataenv][module]" => "messagemodule"
            "[dataenv][time]" => "timestamp"
          }
          add_field => {
            "status" => 500
            "duration_ms" => 0
          }
          replace => {
            "message" => "%{message} [%{messagemodule}]"
            "level" => "error"
          }
          remove_field => ["dataenv"]
          remove_field => ["messagemodule"]
        }
        mutate {
          convert => {
            "exitcode" => "integer"
            "status" => "integer"
            "duration_ms" => "float"
          }
        }
      }

      # do not report errors for babl/events to avoid recursive error notifications #TODO: find better solution!
      if [level] != "info" and [module] != "babl/events" {
        mutate {
          add_field => {
            "[@metadata][__notify]" => "ERROR %{module} on %{host}: %{message}"
          }
        }
      }

      # pipes babl-server messages with "rid": into kafka.logs.qa
      if [message] =~ "\"rid\":.*" {
        mutate {
          add_field => {
            "hostname" => "%{host[-1]}"
            "[@metadata][__logs_rid]" => "logs.qa"
            "[@metadata][__debug]" => true
          }
        }
      }

      # NOTE: mandatory to be the last block, will rename: "[data][message]" => "message"
      mutate {
        rename => {
          "[data][msg]" => "message"
        }
      }
      # remove data field
      mutate {
        remove_field => ["data"]
      }
    }
    #endif [message]
    #endif [type] == "module"
  }
}
output {
  # For debugging
  # stdout { codec => rubydebug { metadata => true } }

  # NOTE: to debug use: add_field => { "[@metadata][__debug]" => true }
  if [@metadata][__debug] {
    stdout { codec => rubydebug { metadata => true } }
  }

  if [@metadata][__logs_rid] {
    kafka {
      bootstrap_servers => "queue.babl.sh:9092"
      topic_id => "%{[@metadata][__logs_rid]}"
    }
  }
}
